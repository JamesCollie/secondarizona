'++LotusScript Development Environment:2:5:(Options):0:74
Option Public
Option Declare


'++LotusScript Development Environment:2:5:(Forward):0:1
Declare Function Word( Byval AString As String, Byval Seperator As String, Byval Number As Integer) As String
Declare Function RemoveSubString( Byval AString As String, Byval SubString As String ) As String
Declare Function ReplaceSubString( Byval AString As String, Byval SubString As String, Byval WithString As String ) As String
Declare Function ProperCase( Byval AString As String) As String
Declare Function NotesDateToText(NotesDate As Variant, Formatting As String) As String
Declare Function FindWildcard (fullString As String, Byval searchString As String, _
startPos As Integer, endPos As Integer) As Integer
Declare Function GetFirstPossibleMatchPos (fullString As String, searchString As String) As Integer
Declare Function ExplodeBracket (bracketString As String, retEndPos As Integer, isInverse As Integer) As String
Declare Function StripChar( Byval AString As String ) As String

'++LotusScript Development Environment:2:5:(Declarations):0:2

'++LotusScript Development Environment:2:1:Word:4:8
'AString is the string you want to extract words from
'Seperator is the character(s) you want to seperate words by
'Number is which word you want: first(1), second(2)...
Function Word( Byval AString As String, Byval Seperator As String, Byval Number As Integer) As String
	Dim Pos As Integer
	
	Pos = Instr( AString, Seperator )
	While Number > 1 And Pos <> 0
		AString = Right( AString, Len( AString ) - Pos )
		Number = Number - 1
		Pos = Instr( AString, Seperator )
	Wend
	If Pos = 0 Then
		Word = AString
	Else
		Word = Left( AString, Pos - 1 )
	End If
	
End Function
'++LotusScript Development Environment:2:1:RemoveSubString:4:8
'AString is the string you want something removed out of
'SubString is the Character(s) you want removed
' *** removes all occurences of SubString ***
Function RemoveSubString( Byval AString As String, Byval SubString As String ) As String
	Dim Pos As Integer
	Dim Length As Integer
	
	Length = Len( AString )
	Pos = Instr( AString, SubString )
	
	While Pos > 0
		If Pos + ( Len( SubString ) - 1 ) >= Length Then
			AString = Left( AString, Pos - 1 )
		Else
			AString = Left( AString, Pos - 1 ) & Right( AString, Length - ( Pos + ( Len( SubString ) - 1 ) ) )
		End If
		Length = Len( AString )
		Pos = Instr( AString, SubString )
	Wend
	
	RemoveSubString = AString
	
End Function
'++LotusScript Development Environment:2:1:ReplaceSubString:5:8
'AString is the string you want something removed out of
'SubString is the Character(s) you want removed
'WithString is the Character(s) you want to replace SubString with.
' *** replaces all occurences of SubString ***
Function ReplaceSubString( Byval AString As String, Byval SubString As String, Byval WithString As String ) As String
	Dim Pos As Integer
	Dim RemainingString As String
	Dim NextPos As Integer
	
	Pos = Instr( AString, SubString )
	
	While Pos > 0
		AString = Left( AString, Pos - 1 ) & WithString & Right( AString, Len( AString ) - ( ( Pos - 1 ) + Len( SubString ) ) )
		RemainingString = Right( AString, Len( AString ) - ( ( Pos - 1 ) + Len( WithString ) ) )
		NextPos = Instr( RemainingString, SubString )
		If NextPos = 0 Then Pos = 0 Else Pos = ( Pos - 1 ) + Len( WithString ) + NextPos
	Wend
	
	ReplaceSubString = AString
	
End Function

'++LotusScript Development Environment:2:1:ProperCase:2:8
'UCases the first letter of each word in AString
Function ProperCase( Byval AString As String) As String
%REM	
	Dim Length As Integer
	Dim Pos As Integer
	
	Length = Len( AString )
	Pos = 1
	
	While Pos <= Length
		While Mid$( AString, Pos, 1 ) = " " And Pos <= Length
			AString = Left( AString, Pos - 1 ) & Lcase( Mid$( Astring, Pos, 1 ) ) & Right( AString, Length - Pos )
			Pos = Pos + 1
		Wend
		If Pos <= Length Then
			AString = Left( AString, Pos - 1 ) & Ucase( Mid$( Astring, Pos, 1 ) ) & Right( AString, Length - Pos )
			Pos = Pos + 1
		End If
		While Mid$( AString, Pos, 1 ) <> " " And Pos <= Length
			AString = Left( AString, Pos - 1 ) & Lcase( Mid$( Astring, Pos, 1 ) ) & Right( AString, Length - Pos )
			Pos = Pos + 1
		Wend
	Wend
	
	ProperCase = AString
%END REM
	ProperCase = Strconv( AString, 3 )
End Function


'++LotusScript Development Environment:2:1:NotesDateToText:1:8
Function NotesDateToText(NotesDate As Variant, Formatting As String) As String
	Dim NDT As NotesDateTime
	'Formatting parameter
	'Long Date = "Long Date"
	'Medium Date = "Medium Date"
	'Short Date = "Short Date"
	
	Set NDT = New NotesDateTime(NotesDate)	
	NotesDateToText = Format(NDT.LSLocalTime,Formatting)
End Function

'++LotusScript Development Environment:2:1:FindWildcard:2:8
Function FindWildcard (fullString As String, Byval searchString As String, _
startPos As Integer, endPos As Integer) As Integer
	'by Julian Robichaux: http://www.nsftools.com/tools/lsbook.htm
	
	'** find a substring within a string, between startPos and endPos,
	'** using wildcard operators (*, ?, and #) in your search expression.
	'** You can also search for lists or ranges of characters (or one of
	'** the wildcard operators as a character) by enclosing them in
	'** brackets []. The rules there are essentially the same as the
	'** rules for the Like operator, except you can additionally search for
	'** a close bracket character inside a set of brackets by doubling it
	'** ( like [asdf]]] will search for the characters a, s, d, f, and ].
	'** If a match is found, the return value will be True and the startPos
	'** and endPos will be reset to give the start and end position of the
	'** matching string
	
	Dim beginStar As Integer, qMarkOffset As Integer
	Dim newChar As String
	Dim ascChar As Integer
	Dim matchChar As String, lastMatchChar As String
	Dim isMatch As Integer
	Dim matchPos As Integer
	Dim getPos As Integer
	Dim retStartPos As Integer, retEndPos As Integer
	Dim ascStar As Integer, ascNum As Integer
	Dim ascQuest As Integer, ascBracket As Integer
	Dim isLastMatchStar As Integer
	Dim bracketText As String
	Dim bracketEndPos As Integer
	Dim isBracketMatchInverse As Integer
	Dim i As Integer
	
	'** exit if there's no search string
	If (Len(fullString) = 0) Or (Len(searchString) = 0) Then
		FindWildcard = False
		startPos = 0
		endPos = 0
		Exit Function
	End If
	
	'** validate the startPos and endPos
	Select Case startPos
	Case Is < 1
		startPos = 1
	Case Is > Len(fullString)
		startPos = Len(fullString)
	End Select
	Select Case endPos
	Case Is < 1
		endPos = Len(fullString)
	Case Is < startPos
		endPos = startPos
	Case Is > Len(fullString)
		endPos = Len(fullString)
	End Select
	
	'** set the starting values of our variables
	FindWildcard = False
	isMatch = False
	ascStar = Asc("*")
	ascNum = Asc("#")
	ascQuest = Asc("?")
	ascBracket = Asc("[")
	isLastMatchStar = False
	
	'** if the searchString begins with wildcard characters, including *,
	'** then we can strip them from the searchString and avoid having to
	'** use them in our search every time (if we end up finding a match,
	'** we can adjust the start position at the end)
	If (Instr(searchString, "*") > 0) Then
		Do Until (matchPos > Len(searchString))
			matchPos = matchPos + 1
			matchChar = Mid$(searchString, matchPos, 1)
			If (matchChar = "*") Then
				beginStar = True
			Elseif (matchChar = "?") Then
				qMarkOffset = qMarkOffset + 1
			Else
				Exit Do
			End If
		Loop
		'** adjust searchString if we found anything
		searchString = Mid$(searchString, matchPos)
	End If
	
	For i = (startPos + qMarkOffset) To endPos
		newChar = Mid(fullString, i, 1)
		ascChar = Asc(newChar)
		'** check the character in the string against the next character
		'** in the searchString
		If Not isMatch Then
			matchPos = 1
			retStartPos = 0
			matchChar = Mid$(searchString, matchPos, 1)
			lastMatchChar = ""
			isLastMatchStar = False
		End If
		
		Select Case Asc(matchChar)
		Case ascStar
			'* = 42
			'** handle this outside the Select Case statement, in case
			'** we have a match plus a * plus nothing else, which means
			'** we should match the rest of the string
			
%REM
need to search for this for conditional correspondence tags
		Case ascQuest
			'? = 63
			'** ? always matches exactly one character
			isMatch = True
			'** get the next searchString character
			lastMatchChar = matchChar
			isLastMatchStar = False
			matchPos = matchPos + 1
			matchChar = Mid$(searchString, matchPos, 1)
%END REM
			
		Case ascNum '# = 35
			'** # always matches exactly one number
			If (Instr("0123456789", newChar) > 0) Then
				isMatch = True
				'** get the next searchString character
				lastMatchChar = matchChar
				isLastMatchStar = False
				matchPos = matchPos + 1
				matchChar = Mid$(searchString, matchPos, 1)
			Elseif isLastMatchStar Then
				'** if we were previously matching with "*", we
				'** should still consider this to be a match, but
				'** we shouldn't advance the matchPos
				isMatch = True
			Else
				isMatch = False
			End If
			
		Case ascBracket '[ = 91
			'** if it's a bracketed match, search for any the
			'** characters within the brackets
			isMatch = False
			bracketText = ExplodeBracket(Mid$(searchString, matchPos), _
			bracketEndPos, isBracketMatchInverse)
			If (Instr(bracketText, newChar) > 0) Then
				isMatch = True
			End If
			'** adjust the match, based on bracketMatchInverse
			isMatch = isMatch Xor isBracketMatchInverse
			If isMatch Then
				'** get the next searchString character
				lastMatchChar = "[]"
				isLastMatchStar = False
				matchPos = matchPos + bracketEndPos
				matchChar = Mid$(searchString, matchPos, 1)
			Elseif isLastMatchStar Then
				'** if we were previously matching with "*", we
				'** should still consider this to be a match, but
				'** we shouldn't advance the matchPos
				isMatch = True
			End If
			
		Case ascChar
			'** this should be an exact match
			isMatch = True
			'** get the next searchString character
			lastMatchChar = matchChar
			isLastMatchStar = False
			matchPos = matchPos + 1
			matchChar = Mid$(searchString, matchPos, 1)
			
		Case Else
			If isLastMatchStar Then
				'** if we were previously matching with "*", we
				'** should still consider this to be a match, but 
				'** we shouldn't advance the matchPos
				isMatch = True
			Else
				isMatch = False
			End If
		End Select
		
		'** handle the special case where matchChar = *
		If (matchChar = "*") Then
			'** the * is always a match
			isMatch = True
			lastMatchChar = "*"
			isLastMatchStar = True
			'** get the next searchString character that's not
			'** a wildcard
			Do Until (matchPos > Len(searchString))
				matchPos = matchPos + 1
				matchChar = Mid$(searchString, matchPos, 1)
				If (matchChar <> "*") And (matchChar <> "?") Then
					Exit Do
				End If
			Loop
		End If
		
		'** if we're in the middle of a match, make sure the startPos
		'** variable is set, and check to see if we found a full match
		If isMatch Then
			'** set the return startPos, if necessary
			If (retStartPos = 0) Then
				retStartPos = i
			End If
			'** if we got to the end of the searchString, then we
			'** found a match
			If (matchPos > Len(searchString)) Then
				If isLastMatchStar Then
					'** if the last character in the searchString
					'** is a "*", then this matches everything
					'** from startPos to the end of the line
					retEndPos = endPos
				Else
					retEndPos = i
				End If
				FindWildcard = True
				Exit For
			Elseif isLastMatchStar Then
				'** speed things up a little by finding the next
				'** character match, if we're looking for *something
				getPos = GetFirstPossibleMatchPos(Mid$(fullString, i + 1), Mid$(searchString, matchPos))
				If (getPos = 0) Then
					Exit For
				Else
					i = i + getPos - 1
				End If
			End If
		Else
			'** couldn't find a match, so let's advance to the
			'** next possible spot
			getPos = GetFirstPossibleMatchPos(Mid$(fullString, i + 1), searchString)
			If (getPos = 0) Then
				Exit For
			Else
				i = i + getPos - 1
			End If
		End If
	Next i
	
	If FindWildcard Then
		If Not beginStar Then
			startPos = retStartPos - qMarkOffset
			'** Else startPos is whatever the user originally passed us
		End If
		endPos = retEndPos
	Else
		startPos = 0
		endPos = 0
	End If
End Function


'++LotusScript Development Environment:2:1:GetFirstPossibleMatchPos:1:8
Function GetFirstPossibleMatchPos (fullString As String, searchString As String) As Integer
	'** get the first position of a possible match within fullString, based on
	'** the wildcard match specifications in searchString
	Dim matchPos As Integer
	Dim matchChar As String
	Dim ascMatchChar As Integer
	Dim bracketText As String
	Dim searchPos As Integer
	Dim firstSearchPos As Integer
	Dim ascStar As Integer, ascNum As Integer
	Dim ascQuest As Integer, ascBracket As Integer
	Dim i As Integer
	
	'** exit early if we got a bogus string
	If (Len(fullString) = 0) Then
		GetFirstPossibleMatchPos = 0
		Exit Function
	End If
	
	'** initialize the variables
	ascStar = Asc("*")
	ascNum = Asc("#")
	ascQuest = Asc("?")
	ascBracket = Asc("[")
	
	'** start searching
	firstSearchPos = 0
	matchPos = 1
	
	Do Until (matchPos > Len(searchString))
		matchChar = Mid$(searchString, matchPos, 1)
		ascMatchChar = Asc(matchChar)
		
		Select Case ascMatchChar
		Case ascStar
			'** loop
		Case ascQuest
			'** loop
		Case ascBracket
			'** if we're matching stuff inside brackets, get the
			'** exploded bracket string and search for all the
			'** characters inside
			bracketText = ExplodeBracket(Mid$(searchString, matchPos), 0, 0)
			For i = 1 To Len(bracketText)
				searchPos = Instr(fullString, Mid$(bracketText, i, 1))
				If (searchPos > 0) Then
					If (searchPos < firstSearchPos) Or (firstSearchPos = 0) Then
						firstSearchPos = searchPos
					End If
				End If
			Next
			Exit Do
		Case ascNum
			'** if we're looking for a number, look for the first
			'** number in the string
			For i = 0 To 9
				searchPos = Instr(fullString, Cstr(i))
				If (searchPos > 0) Then
					If (searchPos < firstSearchPos) Or (firstSearchPos = 0) Then
						firstSearchPos = searchPos
					End If
				End If
			Next
			Exit Do
		Case Else
			'** we're just looking for a single character
			firstSearchPos = Instr(fullString, matchChar)
			Exit Do
		End Select
		matchPos = matchPos + 1
	Loop
	
	'** if we're at the end of the searchString, then we're either searching
	'** for nothing or the entire searchString is just * or ?, so the first
	'** possible match is the beginning of the string
	If (matchPos > Len(searchString)) Then
		GetFirstPossibleMatchPos = 1
		Exit Function
	End If
	
	GetFirstPossibleMatchPos = firstSearchPos
	
End Function


'++LotusScript Development Environment:2:1:ExplodeBracket:1:8
Function ExplodeBracket (bracketString As String, retEndPos As Integer, isInverse As Integer) As String
	'** Convert the given bracketed characters in a wildcard match string
	'** to a string of all characters that would count as a match.
	'** Returns the end position of the brackets, if the user wants them.
	'** Also returns whether the string match is an inverse match.
	Dim char As String
	Dim pos As Integer
	Dim i As Integer
	Dim isBracketRange As Integer
	Dim bracketStartRange As Integer, bracketEndRange As Integer
	
	'** if we're not looking at a bracketed string, just return
	If Not (Left$(bracketString, 1) = "[") Then
		retEndPos = 0
		isInverse = False
		ExplodeBracket = ""
		Exit Function
	End If
	
	'** save some information as static information, so we don't end up
	'** exploding the same bracket string over and over again
	Static lastString As String
	Static lastEndPos As Integer
	Static lastInverse As Integer
	Static lastResult As String
	
	'** if we're looking at the same thing we looked at last time,
	'** just return the same results from last time
	If (bracketString = lastString) Then
		retEndPos = lastEndPos
		isInverse = lastInverse
		ExplodeBracket = lastResult
		Exit Function
	Else
		lastString = bracketString
	End If
	
	If (Mid$(bracketString, 2, 1) = "!") Then
		'** if the first character is a "!", then we're finding anything
		'** that doesn't match the characters in the brackets
		pos = 3
		isInverse = False
	Else
		pos = 2
		isInverse = False
	End If
	
	'** initialize the variables and start going through the brackets
	retEndPos = 2
	isBracketRange = False
	
	Do Until (pos > Len(bracketString))
		char = Mid$(bracketString, pos, 1)
		
		Select Case char
		Case "]"
			If (Mid$(bracketString, pos + 1, 1) = "]") Then
				pos = pos + 1
				char = Mid$(bracketString, pos, 1)
			Else
				' we're at the end of the brackets
				retEndPos = pos
				Exit Do
			End If
		Case "-"
			If (bracketStartRange >= 0) Then
				isBracketRange = True
			End If
		Case Else
			'** continue on
		End Select
		
		'** set the start and end range of the character(s) we're
		'** looking for
		If isBracketRange And (char <> "-") Then
			'** if we're dealing with a range of characters, get the
			'** start and end of the range and list them out
			If (Asc(char) > bracketStartRange) Then
				bracketEndRange = Asc(char)
			Else
				bracketEndRange = bracketStartRange
				bracketStartRange = Asc(char)
			End If
			For i = bracketStartRange To bracketEndRange
				ExplodeBracket = ExplodeBracket & Chr$(i)
			Next
			isBracketRange = False
			
		Elseif Not isBracketRange Then
			ExplodeBracket = ExplodeBracket & char
		End If
		
		'** advance the position and continue
		pos = pos + 1
		
	Loop
	
	'** if we got all the way to the end without finding the close bracket,
	'** just return the end of the string as the end of the brackets
	If (pos > Len(bracketString)) Then
		retEndPos = Len(bracketString)
	End If
	
	'** set the static variables for the next time
	lastEndPos = retEndPos
	lastInverse = isInverse
	lastResult = ExplodeBracket
	
End Function
'++LotusScript Development Environment:2:1:StripChar:1:8
Function StripChar( Byval AString As String ) As String
	'STRIP CARRIAGE RETURNS
	Dim Pos As Integer	
	Dim i As Integer
	
	Pos = Instr( AString, Chr(13) )
	
	If Pos > 0 Then
		For i = 1 To Len( AString )
			If Mid( AString, i, 1 ) = Chr(13) Then
				StripChar = StripChar & ", "
			Elseif Mid( AString, i, 1 ) = Chr(10) Then
				StripChar = StripChar & " "
			Else 
				StripChar = StripChar & Mid( AString, i, 1 )
			End If
		Next
	Else
		StripChar = AString
	End If
	
End Function